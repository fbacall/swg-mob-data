<!DOCTYPE html>
<html>
<head>
    <title>SWG Mob Data</title>
    <meta charset="UTF-8">
    <meta name="author" content="fbacall">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: sans-serif;
            font-size: 14px;
            margin: 0;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        #controls {
            position: fixed;
            top: 0;
            background-color: #ccc;
            padding: 0 10px;
            width: 100%;
            max-width: 1800px;
            line-height: 2em;
            z-index: 100;
        }

        #controls div {
            display: inline-block;
            margin-right: 1em;
            padding-right: 1em;
            border-right: 2px solid #eee;
        }

        #mobs {
            position: relative;
            border-collapse: collapse;
            width: 100%;
        }

        #map {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
        }

        #map.open {
            display: block;
        }

        #map .image {
            background-size: cover;
            margin: 60px auto 0;
            border: 5px solid #333;
            max-width: 80vh;
            max-height: 80vh;
            position: relative;
        }

        #map .image svg {
            width: 100%;
            height: 100%;
        }

        #map .world-spawn {
            position: absolute;
            color: white;
            width: 100%;
            text-align: center;
            top: 50px;
            font-weight: bold;
        }

        #static-spawns {
            display: none;
            background: #eee;
            max-width: 80vh;
            padding: 1em;
            margin: 20px auto;
        }

        tr {
            height: 1.7em;
        }

        th {
            position: sticky;
            top: 0;
            height: 4em;
            padding-top: 2em;
            background-color: #ddd;
        }

        th.resource {
            width: 12em;
        }

        td {
            text-align: center;
            padding: 0 0.5em;
        }

        td.left {
            text-align: left;
        }

        [data-sort] {
            user-select: none;
            cursor: pointer;
        }

        [data-sort]:hover {
            background: #ccccff;
        }

        .sort-desc:after {
            content: '↑';
        }

        .sort-asc:after {
            content: '↓';
        }

        .creature-resource {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: left;
            background: #eee;
        }

        .creature-resource .yield {
            float: right;
            margin-left: 1em;
        }

        .tag {
            border-radius: 2px;
            background: #eee;
            padding: 2px 10px;
            margin: 2px;
            font-size: smaller;
            display: inline-block;
        }

        .spawns {
            display: inline-block;
            cursor: pointer;
            float: right;
            font-size: small;
            color: #5291f2;
            text-decoration: underline;
        }

        .spawns.static-spawns {
            color: #58cb22;
        }

        .spawns:hover {
            color: #9dc5ff;
        }

        .armor { background: #ccc; }
        .mediumdisease, .mediumpoison { color: #e8af27; }
        .strongdisease, .strongpoison { color: #a90a0a; }
        .ranged { background: #a5edff; }
        .no-resist { color: #bbb; }
        .vulnerable { color: #55a632; }

        .bronze { color: #8d5213; }
        .silver { color: #778; }
        .gold { color: #907a33; }
        .omg { color: #c91414; }

        .bone_avian { background-color: #80c4d7; }
        .bone_mammal { background-color: #a9a9a9; }
        .hide_bristley { background-color: #f9b660; }
        .hide_leathery { background-color: #ffd516; }
        .hide_scaley { background-color: #7ed52c; }
        .hide_wooly { background-color: #b08056; }
        .meat_avian { background-color: #80c4d7; }
        .meat_carnivore { background-color: #ff9d93; }
        .meat_domesticated { background-color: #c6a90f; }
        .meat_herbivore { background-color: #aae798; }
        .meat_insect { background-color: #cd9ced; }
        .meat_reptilian { background-color: #f79f23; }
        .meat_wild { background-color: #d27320; }
        .milk_wild { background-color: #cafffe; }
        .milk_domesticated { background-color: #c6a90f; }

        td.planet {
            text-align: center;
            font-weight: bold;
            padding: 0.5em;
        }
        .corellia { background-color: #b7e9e7; }
        .dantooine { background-color: #ff00ff; }
        .dathomir { background-color: #8634ea; }
        .endor { background-color: #358216; }
        .lok { background-color: #e9c43b; }
        .naboo { background-color: #84c267; }
        .rori { background-color: #ea8050; }
        .talus { background-color: #4aeecb; }
        .tatooine { background-color: #ffe100; }
        .yavin4 { background-color: #6aff00; }

        .map-corellia { background-image: url('img/corellia.jpg'); }
        .map-dantooine { background-image: url('img/dantooine.jpg'); }
        .map-dathomir { background-image: url('img/dathomir.jpg'); }
        .map-endor { background-image: url('img/endor.jpg'); }
        .map-lok { background-image: url('img/lok.jpg'); }
        .map-naboo { background-image: url('img/naboo.jpg'); }
        .map-rori { background-image: url('img/rori.jpg'); }
        .map-talus { background-image: url('img/talus.jpg'); }
        .map-tatooine { background-image: url('img/tatooine.jpg'); }
        .map-yavin4 { background-image: url('img/yavin4.jpg'); }
    </style>
</head>
<body>

<div class="container">
    <div id="map">
        <div class="image"></div>
        <pre id="static-spawns"></pre>
    </div>

    <div id="controls">
        <div>
            Planet:
            <select id="planet-filter">
                <option value="">(Any)</option>
                <option value="corellia">Corellia</option>
                <option value="dantooine">Dantooine</option>
                <option value="dathomir">Dathomir</option>
                <option value="endor">Endor</option>
                <option value="lok">Lok</option>
                <option value="naboo">Naboo</option>
                <option value="rori">Rori</option>
                <option value="talus">Talus</option>
                <option value="tatooine">Tatooine</option>
                <option value="yavin4">Yavin IV</option>
            </select>
        </div>
        <div>
            <label for="spawn-filter">Include spawns?</label>
            <input type="checkbox" id="spawn-filter"/>
        </div>
        <div>
            <label for="npc-filter">Include NPCs?</label>
            <input type="checkbox" id="npc-filter"/>
        </div>
    </div>
    <table id="mobs" style="visibility: hidden;">
        <thead>
            <tr>
                <th data-sort="name">Creature</th>
                <th data-sort="level" class="sort-asc">CL</th>
                <th class="resource" data-sort="meat">Meat</th>
                <th class="resource" data-sort="hide">Hide</th>
                <th class="resource" data-sort="bone">Bone</th>
                <th class="resource" data-sort="milk">Milk</th>
                <th>Info</th>
                <th data-sort="kinetic_resist">Kin</th>
                <th data-sort="energy_resist">Ene</th>
                <th data-sort="ham">HAM</th>
                <th data-sort="xp">XP</th>
            </tr>
        </thead>
        <tbody>
        </tbody>
    </table>
</div>

<script>
    document.addEventListener("DOMContentLoaded", init);
    let mobData = null;
    let missionData = null;
    let regionData = null;
    let staticSpawnData = null;
    let planetData = {};
    let sort = 'level';
    let sortDir = 1;

    function init() {
        fetch('data/mobs.json')
            .then((response) => response.json())
            .then((data) => {
                mobData = data;
                combine();
            });
        fetch('data/missions.json')
            .then((response) => response.json())
            .then((data) => {
                missionData = data;
                combine();
            });
        fetch('data/regions.json')
            .then((response) => response.json())
            .then((data) => {
                regionData = data;
                combine();
            });
        fetch('data/static_spawns.json')
            .then((response) => response.json())
            .then((data) => {
                staticSpawnData = data;
                combine();
            });
    }

    function combine() {
        if (!mobData || !missionData || !regionData || !staticSpawnData) {
            return;
        }

        for (const [planet, missions] of Object.entries(missionData)) {
            planetData[planet] = [];
            missions.forEach(mission => {
                mission.mobs.forEach(mobName => {
                    if (mobData[mobName]) {
                        let planetMob = planetData[planet].find(m => m.name === mobName);
                        if (planetMob) {
                            planetMob.min_cl = Math.min(planetMob.min_cl, mission.min_cl);
                            planetMob.max_cl = Math.max(planetMob.max_cl, mission.max_cl);
                        } else {
                            planetMob = { ...mobData[mobName] };
                            planetMob.min_cl = mission.min_cl;
                            planetMob.max_cl = mission.max_cl;
                            planetData[planet].push(planetMob);
                        }

                    }
                })
            });
        }

        for (const [planet, regions] of Object.entries(regionData)) {
            if (!planetData[planet]) {
                planetData[planet] = [];
            }
            for (const [regionName, region] of Object.entries(regions)) {
                region.mobs.forEach(mobName => {
                    if (mobData[mobName]) {
                        let planetMob = planetData[planet].find(m => m.name === mobName);
                        if (planetMob) {
                            if (!planetMob.regions) {
                                planetMob.regions = [];
                            }
                            if (!planetMob.regions.find(r => r.name === region.name)) {
                                planetMob.regions.push(region);
                            }
                        } else {
                            planetMob = { ...mobData[mobName] };
                            planetMob.regions = [region];
                            planetData[planet].push(planetMob);
                        }
                    }
                })
            }
        }

        for (const [planet, staticSpawns] of Object.entries(staticSpawnData)) {
            if (!planetData[planet]) {
                planetData[planet] = [];
            }
            for (const [mobName, spawns] of Object.entries(staticSpawns)) {
                console.log(mobName);
                if (mobData[mobName]) {
                    let planetMob = planetData[planet].find(m => m.name === mobName);
                    if (planetMob) {
                        if (!planetMob.staticSpawns) {
                            planetMob.staticSpawns = [];
                        }
                        planetMob.staticSpawns = planetMob.staticSpawns.concat(spawns);
                    } else {
                        planetMob = { ...mobData[mobName] };
                        planetMob.staticSpawns = spawns;
                        planetData[planet].push(planetMob);
                    }
                }
            }
        }

        draw();
        document.getElementById('mobs').style.visibility = '';
        redraw();
    }

    function draw() {
        const tbody = document.getElementById('mobs').getElementsByTagName('tbody')[0];
        for (const [planet, mobs] of Object.entries(planetData)) {
            mobs.forEach(function (mob) {
                const row = tbody.insertRow();
                // Name
                const name = row.insertCell();
                if (mob.type === 'MOB_DROID' || mob.type === 'MOB_ANDROID') {
                    mob.humanName = mob.name.split('_').map(s => s.toUpperCase()).join('-');
                } else {
                    mob.humanName = mob.name.split('_').map(s => capitalize(s)).join(' ');
                }
                name.classList.add('left');
                name.appendChild(document.createTextNode(mob.humanName));
                if (mob.regions || mob.staticSpawns) {
                    const spawns = document.createElement('span');
                    spawns.classList.add('spawns');
                    if (mob.staticSpawns) {
                        spawns.classList.add('static-spawns');
                    }
                    spawns.dataset.mob = mob.name;
                    spawns.dataset.planet = planet;
                    spawns.appendChild(document.createTextNode('Map'));
                    name.appendChild(spawns);
                }
                // CL
                const cl = row.insertCell();
                if (mob.min_cl) {
                    cl.appendChild(document.createTextNode('' + mob.min_cl + '-' + mob.max_cl));
                } else {
                    cl.appendChild(document.createTextNode('' + mob.level + '*'));
                }
                // Meat
                drawResource(row.insertCell(), mob.meat_type, mob.meat);
                // Hide
                drawResource(row.insertCell(), mob.hide_type, mob.hide);
                // Bone
                drawResource(row.insertCell(), mob.bone_type, mob.bone);
                // Milk
                drawResource(row.insertCell(), mob.milk_type, mob.milk);
                // Info
                const info = row.insertCell();
                info.classList.add('left');
                // AR
                if (mob.armor && mob.armor > 0) {
                    const ar = document.createElement('span');
                    ar.classList.add('tag', 'armor', 'armor-' + mob.armor);
                    ar.appendChild(document.createTextNode('AR:' + mob.armor));
                    info.appendChild(ar);
                }
                mob.attacks.sort().forEach(attack => {
                    const tag = document.createElement('span');
                    tag.classList.add('tag', attack.split(' ')[0]);
                    let tagText = attack.replace('creaturearea', 'AoE ');
                    tagText = tagText.replace('attack', '');
                    tagText = tagText.replace('mild', '');
                    tagText = tagText.replace('medium', '');
                    tagText = tagText.replace('strong', '');
                    tag.appendChild(document.createTextNode(tagText));
                    info.appendChild(tag);
                });

                // Kinetic
                drawResist(row.insertCell(), mob.kinetic_resist);
                // Energy
                drawResist(row.insertCell(), mob.energy_resist);
                // HAM
                drawNum(row.insertCell(), mob.ham);
                // XP
                drawNum(row.insertCell(), mob.xp);

                mob.row = row;
            });
        }
    }

    function redraw() {
        const tbody = document.getElementById('mobs').getElementsByTagName('tbody')[0];
        tbody.querySelectorAll('tr.planet').forEach(row => row.remove());

        for (const [planet, mobs] of Object.entries(planetData)) {
            applySort(mobs);
            const filteredMobs = applyFilter(mobs, planet);
            if (filteredMobs.length && !document.getElementById('planet-filter').value) {
                drawPlanetRow(tbody, planet);
            }
            mobs.forEach(function (mob) {
                tbody.appendChild(mob.row);
                mob.row.style.display = 'none';
            });
            filteredMobs.forEach(function (mob) {
                mob.row.style.display = '';
            });
        }
    }

    function applyFilter(mobs, planet) {
        const planetFilter = document.getElementById('planet-filter').value;
        const includeSpawns = document.getElementById('spawn-filter').checked;
        const includeNpcs = document.getElementById('npc-filter').checked;
        return mobs.filter(function (mob) {
            if (planetFilter && (planetFilter !== planet)) {
                return false;
            }
            if (!includeSpawns && !mob.min_cl) {
                return false;
            }
            if (!includeNpcs && !(mob.type === 'MOB_CARNIVORE' || mob.type === 'MOB_HERBIVORE')) {
                return false;
            }
            return true;
        });
    }

    function applySort(mobs) {
        let f;
        if (sort === 'name') {
            f = (a, b) => {
                if (a.name.toUpperCase() > b.name.toUpperCase()) {
                    return sortDir;
                }
                if (a.name.toUpperCase() < b.name.toUpperCase()) {
                    return -sortDir;
                }
                return 0;
            }
        } else if (sort === 'meat' || sort === 'bone' || sort === 'hide' || sort === 'milk') {
            const typeVar = sort + '_type';
            f = (a, b) => {
                const aType = a[typeVar] || '0';
                const bType = b[typeVar] || '0';
                if (aType.toUpperCase() > bType.toUpperCase()) {
                    return sortDir;
                }
                if (aType.toUpperCase() < bType.toUpperCase()) {
                    return -sortDir;
                }
                return (a[sort] - b[sort]) * sortDir;
            }
        } else if (sort === 'level') {
            f = (a, b) => ((a.min_cl || a.level) - (b.min_cl || b.level)) * sortDir;
        }else {
            f = (a, b) => (a[sort] - b[sort]) * sortDir;
        }
        mobs.sort(f);
    }

    function drawPlanetRow(tbody, planet) {
        const planetRow = tbody.insertRow();
        planetRow.classList.add('planet', planet);
        const planetCell = planetRow.insertCell();
        planetCell.innerText = capitalize(planet);
        planetCell.colSpan = 11;
        return planetRow;
    }

    function drawResource(cell, type, qty) {
        cell.classList.add('creature-resource');
        if (type) {
            cell.classList.add(type);
            const name = type.split('_')[1];
            cell.innerHTML = '<div class="yield">' + qty +'</div>' + capitalize(name);
        }
    }

    function drawResist(cell, resist) {
        if (resist === 0) {
            cell.classList.add('no-resist');
        } else if (resist === 'Vul') {
            cell.classList.add('vulnerable');
        }

        cell.appendChild(document.createTextNode(resist));
    }

    function drawNum(cell, num) {
        let text = num;
        if (num > 1000) {
            text = (num / 1000).toString().substr(0, 3);
            text = text.replace('.0', '');
            if (text[text.length - 1] === '.') // Strip trailing .
                text = text.substring(0, text.length - 1);
            text += 'K';
            if (num > 50000) {
                cell.classList.add('omg');
            } else if (num > 10000) {
                cell.classList.add('gold');
            } else if (num > 5000) {
                cell.classList.add('silver');
            } else {
                cell.classList.add('bronze');
            }
        }

        cell.appendChild(document.createTextNode(text));
    }

    function drawMap(element) {
        const mob = planetData[element.dataset.planet].find(m => m.name === element.dataset.mob);
        const bg = document.getElementById('map');
        bg.classList.add('open');
        const map = bg.querySelector('.image');
        map.classList.add('map-' + element.dataset.planet);
        map.innerHTML = '';
        const svg = svgNode('svg', { viewBox: '0 0 16000 16000' });
        map.appendChild(svg);

        if (mob.regions) {
            mob.regions.forEach(region => {
                if (region.name.includes('world_spawner')) {
                    const worldSpawn = document.createElement('div');
                    worldSpawn.classList.add('world-spawn');
                    worldSpawn.appendChild(document.createTextNode('(Can also spawn globally)'));
                    map.appendChild(worldSpawn);
                } else {
                    if (region.shape[0] === 'rectangle') {
                        const x1 = region.shape[1] + 8000;
                        const y1 = 8000 - region.shape[2];
                        const x2 = region.shape[3] + 8000;
                        const y2 = 8000 - region.shape[4];
                        const x = Math.min(x1, x2);
                        const y = Math.min(y1, y2);
                        const width = Math.max(x1, x2) - x;
                        const height = Math.max(y1, y2) - y;
                        svg.appendChild(svgNode('rect', { x: x, y: y, width: width, height: height, fill: '#ff000066' }));
                    } else if (region.shape[0] === 'circle') {
                        const x = region.shape[1] + 8000;
                        const y = 8000 - region.shape[2];
                        const r = region.shape[3];
                        svg.appendChild(svgNode('circle', { cx: x, cy: y, r: r, fill: '#ff000066' }));
                    }
                }
            });
        }

        const staticSpawnList = document.getElementById('static-spawns');
        if (mob.staticSpawns) {
            staticSpawnList.style.display = 'block';
            staticSpawnList.innerText = '';
            staticSpawnList.appendChild(document.createTextNode("# Static spawns:\n"));
            mob.staticSpawns.forEach(spawn => {
                const x = spawn[0] + 8000;
                const y = 8000 - spawn[1];
                const r = 100;
                const text = '/waypoint ' + spawn[0] + ' ' + spawn[1] + ' ' + mob.name;
                svg.appendChild(svgNode('circle', { cx: x, cy: y, r: r, fill: '#58cb22', title: text }));
                staticSpawnList.appendChild(document.createTextNode(text + "\n"));
            });
            bg.appendChild(staticSpawnList);
        } else {
            staticSpawnList.style.display = 'none';
        }
    }

    function capitalize(string) {
        return string[0].toUpperCase() + string.slice(1)
    }

    function svgNode(node, props) {
        const n = document.createElementNS("http://www.w3.org/2000/svg", node);
        if (props) {
            for (const [key, value] of Object.entries(props)) {
                n.setAttributeNS(null, key, value);
            }
        }
        return n;
    }

    document.getElementById('mobs').addEventListener('click', function (e) {
        if (e.target.dataset.sort) {
            document.querySelectorAll('.sort-desc').forEach(n => n.classList.remove('sort-desc'));
            document.querySelectorAll('.sort-asc').forEach(n => n.classList.remove('sort-asc'));
            if (sort === e.target.dataset.sort) {
                sortDir = sortDir * -1;
            } else {
                sortDir = 1;
                sort = e.target.dataset.sort;
            }
            e.target.classList.add(sortDir === 1 ? 'sort-asc' : 'sort-desc');
            redraw();
        } else if (e.target.dataset.mob) {
            drawMap(e.target);
        }
    });

    document.getElementById('map').addEventListener('click', function (e) {
        if (e.target === this) {
            this.classList.remove('open');
        }
    });

    document.getElementById('planet-filter').addEventListener('change', function (e) {
        setTimeout(redraw, 5);
    });

    document.getElementById('spawn-filter').addEventListener('change', function (e) {
        setTimeout(redraw, 5);
    });

    document.getElementById('npc-filter').addEventListener('change', function (e) {
        setTimeout(redraw, 5);
    });
</script>
</body>
</html>