<!DOCTYPE html>
<html>
<head>
    <title>SWG Mob Data</title>
    <meta charset="UTF-8">
    <meta name="author" content="fbacall">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <style>
        * {
            box-sizing: border-box;
        }

        :root {
            --text: #333;
            --bg: #fff;
            --link: #1854ff;
            --link-hover: #6076ff;
            --muted: #bbb;
            --controls: #ddd;
            --hover: #eee;
            --border: #aaa;
            --btn: #ccc;

            --row: #fff;
            --row-odd: #eee;
            --armor: #ccc;

            --static-spawns: #eeb80a;

            --tag: #ddd;
            --medium-strength: #ffdc56;
            --strong-strength: #ff694b;
            --ranged: #a5edff;
            --no-resist: #bbb;
            --vulnerable: #55a632;

            --bronze: #8d5213;
            --silver: #778;
            --gold: #907a33;
            --omg: #c91414;

            --bone_avian: #80c4d7;
            --bone_mammal: #cccccc;
            --hide_bristley: #f9b660;
            --hide_leathery: #ffd516;
            --hide_scaley: #7ed52c;
            --hide_wooly: #b9906b;
            --meat_avian: #80c4d7;
            --meat_carnivore: #ff9d93;
            --meat_domesticated: #c6a90f;
            --meat_herbivore: #aae798;
            --meat_insect: #cd9ced;
            --meat_reptilian: #f79f23;
            --meat_wild: #d89558;
            --milk_wild: #cafffe;
            --milk_domesticated: #f5efb8;
        }

        :root[data-theme=dark] {
            --text: #fff;
            --bg: #000;
            --link: #5d83ff;
            --link-hover: #9fb8ff;
            --muted: #bbb;
            --controls: #444;
            --hover: #666;
            --border: #111;
            --btn: #666;

            --row: #222;
            --row-odd: #111;
            --armor: #777;

            --static-spawns: #ffee00;

            --tag: #444;
            --medium-strength: #9c7324;
            --strong-strength: #7c0a0a;
            --ranged: #235265;
            --no-resist: #bbb;
            --vulnerable: #55a632;

            --bronze: #ca7914;
            --silver: #a5a5b6;
            --gold: #ccb046;
            --omg: #ff2b2b;

            --bone_avian: #314c58;
            --bone_mammal: #898989;
            --hide_bristley: #a97c43;
            --hide_leathery: #b59714;
            --hide_scaley: #386314;
            --hide_wooly: #513d2c;
            --meat_avian: #314c58;
            --meat_carnivore: #704340;
            --meat_domesticated: #564708;
            --meat_herbivore: #465d3c;
            --meat_insect: #503b5c;
            --meat_reptilian: #815411;
            --meat_wild: #7e5934;
            --milk_wild: #5f7b7a;
            --milk_domesticated: #7b755c;
        }

        body {
            font-family: sans-serif;
            font-size: 14px;
            margin: 0;
            background: var(--bg);
            color: var(--text);
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            border: 2px solid var(--border);
        }

        #controls {
            position: fixed;
            top: 0;
            background-color: var(--controls);
            width: 100%;
            line-height: 2em;
            z-index: 100;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        div.control {
            padding: 5px;
            display: inline-block;
        }

        #open-controls {
            display: none !important;
        }

        #text-filter {
            padding-right: 20px;
        }

        #clear-text-filter {
            position: absolute;
            margin-left: -18px;
            font-size: 18px;
            font-weight: bold;
            text-decoration: none;
            color: #666;
            display: none;
            cursor: pointer;
        }

        .input, .btn {
            border: none;
            line-height: 2em;
            padding: 0 10px;
        }

        .input { }

        .btn {
            text-align: center;
            background-color: var(--btn);
            cursor: pointer;
            color: var(--text);
            user-select: none;
            display: inline-block;
        }

        .btn * {
            cursor: pointer;
        }

        .btn:hover {
            background: var(--hover);
        }

        #mobs {
            position: relative;
            border-collapse: collapse;
            width: 100%;
        }

        #overlay {
            display: none;
            position: fixed;
            z-index: 120;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.8);
        }

        #overlay.open {
            display: block;
        }

        #close-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 64px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
        }

        #map .image {
            background-size: cover;
            border: 2px solid var(--border);
            position: relative;
        }

        #map .image svg {
            width: 100%;
            height: 100%;
        }

        #map .world-spawn {
            position: absolute;
            color: white;
            width: 100%;
            text-align: center;
            top: 50px;
            font-weight: bold;
        }

        .popup-window {
            margin: 30px auto 0;
            width: 80vmin;
            position: relative;
        }

        .box {
            border: 2px solid var(--border);
            background: var(--controls);
            padding: 10px;
        }

        #coords {
            font-size: large;
            font-family: monospace;
            text-align: right;
            position: absolute;
            right: 10px;
            bottom: 10px;
            color: #fff;
            text-shadow: 1px 1px #000;
        }

        #static-spawns {
            margin: 20px auto;
            background: var(--controls);
            padding: 1em;
            border: 2px solid var(--border);
        }

        tr {
            height: 1.7em;
            background-color: var(--row);
        }

        tr:nth-child(odd) {
            background-color: var(--row-odd);
        }

        th {
            position: sticky;
            top: 0;
            height: 4.5em;
            padding-top: 3em;
            background-color: var(--row-odd);
            z-index: 90;
        }

        th.name-column {
            min-width: 16em;
        }

        th.resource-column {
            width: 8em;
        }

        td {
            text-align: center;
            padding: 0 0.5em;
        }

        td.left {
            text-align: left;
        }

        td.info {
            text-align: left;
            white-space: nowrap;
        }

        [data-sort] {
            user-select: none;
            cursor: pointer;
            text-decoration: underline;
        }

        [data-sort]:hover {
            background: var(--hover);
        }

        .sort-desc:after {
            content: '↑';
            display: inline-block;
        }

        .sort-asc:after {
            content: '↓';
            display: inline-block;
        }

        .creature-resource {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: left;
            font-size: smaller;
            line-height: 100%;
        }

        .creature-resource .yield {
            float: right;
            margin-left: 1em;
            font-size: small;
        }

        .creature-resource .short-type {
            display: none;
            font-size: smaller;
            opacity: 0.6;
        }

        .tag {
            border-radius: 2px;
            background: var(--tag);
            padding: 2px 5px;
            margin-right: 2px;
            font-size: smaller;
            display: inline-block;
        }

        .clickable {
            cursor: pointer;
            color: var(--link);
            text-decoration: underline;
        }

        .spawns {
            display: inline-block;
            float: right;
            font-size: small;
        }

        .spawns.static-spawns:after {
            content: '•';
            color: var(--static-spawns);
            position: absolute;
            vertical-align: super;
            font-weight: bold;
        }

        .static-spawns-key {
            color: var(--static-spawns);
            font-weight: bold;
            font-size: large;
        }

        .no-missions:after {
            content: '†';
            position: absolute;
            font-size: 10px;
            vertical-align: super;
        }

        .clickable:hover {
            color: var(--link-hover);
        }

        @media screen and (max-width: 720px) {
            #open-controls {
                display: block !important;
                position: absolute;
                right: 5px;
                top: 5px;
                line-height: 2em;
            }

            #open-controls .btn:after {
                content: '↓';
            }

            #controls.open #open-controls .btn:after {
                content: '↑';
            }

            #controls.open {
                overflow: unset;
                white-space: unset;
            }

            .creature-resource {
                text-overflow: unset;
            }

            .creature-resource .yield {
                font-weight: bold;
            }

            .creature-resource .short-type {
                display: inline;
            }

            .creature-resource .type {
                display: none;
            }
        }

        .armor { background: var(--armor); }
        .armor-2 { background: var(--medium-strength); }
        .armor-3 { background: var(--strong-strength); }
        .mediumdisease, .mediumpoison { background-color: var(--medium-strength); }
        .strongdisease, .strongpoison { background-color: var(--strong-strength); }
        .ranged { background: var(--ranged); }
        .no-resist { color: var(--muted); }
        .vulnerable { color: var(--vulnerable); }

        .bronze { color: var(--bronze); }
        .silver { color: var(--silver); }
        .gold { color: var(--gold); }
        .omg { color: var(--omg); }

        .bone_avian { background-color: var(--bone_avian); }
        .bone_mammal { background-color: var(--bone_mammal); }
        .hide_bristley { background-color: var(--hide_bristley); }
        .hide_leathery { background-color: var(--hide_leathery); }
        .hide_scaley { background-color: var(--hide_scaley); }
        .hide_wooly { background-color: var(--hide_wooly); }
        .meat_avian { background-color: var(--meat_avian); }
        .meat_carnivore { background-color: var(--meat_carnivore); }
        .meat_domesticated { background-color: var(--meat_domesticated); }
        .meat_herbivore { background-color: var(--meat_herbivore); }
        .meat_insect { background-color: var(--meat_insect); }
        .meat_reptilian { background-color: var(--meat_reptilian); }
        .meat_wild { background-color: var(--meat_wild); }
        .milk_wild { background-color: var(--milk_wild); }
        .milk_domesticated { background-color: var(--milk_domesticated); }

        tr.planet {
            text-align: center;
            font-weight: bold;
            padding: 0.5em;
            color: #333 !important;
        }
        .corellia { background-color: #b7e9e7 !important; }
        .dantooine { background-color: #ff9cef !important; }
        .dathomir { background-color: #ae81ea !important; }
        .endor { background-color: #49c53b !important; }
        .lok { background-color: #e2a044 !important; }
        .naboo { background-color: #83e144 !important; }
        .rori { background-color: #eaa071 !important; }
        .talus { background-color: #4aeecb !important; }
        .tatooine { background-color: #ffe100 !important; }
        .yavin4 { background-color: #aac292 !important; }

        .map-corellia { background-image: url('img/corellia.jpg'); }
        .map-dantooine { background-image: url('img/dantooine.jpg'); }
        .map-dathomir { background-image: url('img/dathomir.jpg'); }
        .map-endor { background-image: url('img/endor.jpg'); }
        .map-lok { background-image: url('img/lok.jpg'); }
        .map-naboo { background-image: url('img/naboo.jpg'); }
        .map-rori { background-image: url('img/rori.jpg'); }
        .map-talus { background-image: url('img/talus.jpg'); }
        .map-tatooine { background-image: url('img/tatooine.jpg'); }
        .map-yavin4 { background-image: url('img/yavin4.jpg'); }
    </style>
</head>
<body>
<div id="controls">
    <div id="open-controls">
        <div class="btn"> </div>
    </div>
    <div class="control">
        <select id="planet-filter">
            <option value="">(Any planet)</option>
            <option value="corellia">Corellia</option>
            <option value="dantooine">Dantooine</option>
            <option value="dathomir">Dathomir</option>
            <option value="endor">Endor</option>
            <option value="lok">Lok</option>
            <option value="naboo">Naboo</option>
            <option value="rori">Rori</option>
            <option value="talus">Talus</option>
            <option value="tatooine">Tatooine</option>
            <option value="yavin4">Yavin IV</option>
        </select>
    </div>
    <div class="control">
        <div class="btn">
            <label for="spawn-filter">Spawns?</label>
            <input type="checkbox" id="spawn-filter"/>
        </div>
    </div>
    <div class="control">
        <div class="btn">
            <label for="npc-filter">NPCs?</label>
            <input type="checkbox" id="npc-filter"/>
        </div>
    </div>
    <div class="control">
        <input class="input" type="text" id="text-filter" placeholder="Filter..."/>
        <span id="clear-text-filter">×</span>
    </div>
    <div class="control">
        <button class="btn" onclick="openOverlay('info')">Info & Settings</button>
    </div>
</div>

<div class="container">
    <div id="overlay">
        <div id="map" class="popup-window" data-overlay="map">
            <div class="box">
                <h1 id="mob-name"></h1>
                <div style="position: relative">
                    <div class="image"></div>
                    <div id="coords"></div>
                </div>
                <pre id="static-spawns"></pre>
            </div>
        </div>
        <div id="info" class="popup-window" data-overlay="info">
            <div class="box" style="overflow: auto;">
                <h1>Info and settings</h1>
                <div style="float: right;">
                    Table columns
                    <table>
                        <tbody>
                        <tr><td><input type="checkbox" data-toggle-column="level"></td><td>CL</td><td>Combat Level</td></tr>
                        <tr><td><input type="checkbox" data-toggle-column="meat"></td><td>Meat</td><td>Meat type and amount</td></tr>
                        <tr><td><input type="checkbox" data-toggle-column="hide"></td><td>Hide</td><td>Hide type and amount</td></tr>
                        <tr><td><input type="checkbox" data-toggle-column="bone"></td><td>Bone</td><td>Bone type and amount</td></tr>
                        <tr><td><input type="checkbox" data-toggle-column="milk"></td><td>Milk</td><td>Milk type and amount</td></tr>
                        <tr><td><input type="checkbox" data-toggle-column="info"></td><td>Info</td><td>Combat abilities, armor and other info</td></tr>
                        <tr><td><input type="checkbox" data-toggle-column="kinetic_resist"></td><td>Kin</td><td>Kinetic resistance</td></tr>
                        <tr><td><input type="checkbox" data-toggle-column="energy_resist"></td><td>Ene</td><td>Energy resistance</td></tr>
                        <tr><td><input type="checkbox" data-toggle-column="blast_resist"></td><td>Bla</td><td>Blast resistance</td></tr>
                        <tr><td><input type="checkbox" data-toggle-column="heat_resist"></td><td>Hea</td><td>Heat resistance</td></tr>
                        <tr><td><input type="checkbox" data-toggle-column="cold_resist"></td><td>Col</td><td>Cold resistance</td></tr>
                        <tr><td><input type="checkbox" data-toggle-column="electric_resist"></td><td>Ele</td><td>Electric resistance</td></tr>
                        <tr><td><input type="checkbox" data-toggle-column="acid_resist"></td><td>Aci</td><td>Acid resistance</td></tr>
                        <tr><td><input type="checkbox" data-toggle-column="stun_resist"></td><td>Stu</td><td>Stun resistance</td></tr>
                        <tr><td><input type="checkbox" data-toggle-column="lightsaber_resist"></td><td>Lig</td><td>Lightsaber resistance</td></tr>
                        <tr><td><input type="checkbox" data-toggle-column="ham"></td><td>HAM</td><td>Health, Action and Mind pools</td></tr>
                        <tr><td><input type="checkbox" data-toggle-column="xp"></td><td>XP</td><td>Experience granted</td></tr>
                        </tbody>
                    </table>
                </div>
                <div style="float: left">
                    <span class="static-spawns-key">•</span> - Static spawns available<br/>
                    † - No missions available<br/>
                    <br/>
                    <div class="btn">
                        <label for="dark-mode">Dark mode?</label>
                        <input type="checkbox" id="dark-mode"/>
                    </div>
                </div>
            </div>
        </div>
        <div id="close-overlay">&times;</div>
    </div>

    <table id="mobs" style="visibility: hidden;">
        <thead>
        </thead>
        <tbody>
        </tbody>
    </table>
</div>

<script>
    document.addEventListener("DOMContentLoaded", init);
    const cities = {"corellia":[["Bela Vistal",6766,-5692,370],["Coronet",-178,-4504,581],["Doaba Guerfel",3240,5391,516],["Kor Vella",-3420,3146,620],["Tyrena",-5217,-2456,619],["Vreni Island",-5399,-6296,359]],"dantooine":[["Dantooine Mining Outpost",-640,2486,135],["Dantooine Agro Outpost",1588,-6399,135],["Dantooine Imperial Outpost",-4224,-2400,250]],"dathomir":[["Trade Outpost",599,3046,110],["Science Outpost",-85,-1600,125]],"endor":[["Smuggler Outpost",-905,1584,130],["Research Outpost",3221,-3471,100]],"lok":[["Nym's Stronghold",450,5214,501]],"naboo":[["Theed",-5262,4252,836],["Keren",1616,2736,822],["Moenia",4786,-4729,379],["The Lake Retreat",-5494,-21,190],["Deeja Peak",5003,-1458,542],["Kaadara",5190,6700,324]],"rori":[["Narmle",-5267,-2258,378],["Restuss",5318,5680,325],["Rebel Outpost",3677,-6447,80]],"talus":[["Dearic",422,-3004,435],["Nashal",4348,5245,390],["Talus Imperial Outpost",-2178,2300,150]],"tatooine":[["Bestine",-1204,-3692,375],["Mos Espa",-2878,2226,435],["Mos Eisley",3693,-4788,688],["Mos Entha",1344,3149,516],["Mos Taike",3847,2336,150],["Anchorhead",40,-5348,330],["Wayfar",-5176,-6574,165]],"yavin4":[["Yavin IV Mining Outpost",-312,4865,100],["Yavin IV Labor Outpost",-6925,-5707,130]]};
    const textFilterable = ['name', 'meat_type', 'hide_type', 'bone_type', 'milk_type'];
    const resists = ['kinetic', 'energy', 'blast', 'heat', 'cold', 'electric', 'acid', 'stun', 'lightsaber'];
    const missionRewardFactor = 375;
    const missionRandomRewardFactor = 15;
    const ijmFactor = 1.15;
    const ignoredTags = [
        /marksman/, /pistoleer/, /carbineer/, /rifleman/,
        /brawler/, /tka/, /fencer/, /swordsman/, /pikeman/,
        /commando/, /bountyhunter/
    ];
    let data = null;
    let planetData = {};
    let sort = 'level';
    let sortDir = 1;

    function init() {
        fetch('data/finalizer.json').then(r => r.json()).then(d => { data = d; }).then(parseData);
    }

    class Mob {
        constructor (data = {}) {
            Object.assign(this, data);
            if (!this.lairs) {
                this.lairs = [];
            }
            if (!this.staticSpawns) {
                this.staticSpawns = {};
            }
            resists.forEach((res, i) => {
                this[res + '_resist'] = this.resists[i];
            });
        }

        spawns () {
            return this.lairs.flatMap(l => l.spawns);
        }

        regions () {
            const o = {};
            this.spawns().forEach(s => {
                for (const [planet, regions] of Object.entries(s.regions || {})) {
                    if (!o[planet]) {
                        o[planet] = [];
                    }
                    o[planet] = [...new Set([...o[planet], ...regions])];
                }
            });
            return o;
        }

        missions () {
            const o = {};
            this.lairs.forEach(l => {
                for (const [planet, missions] of Object.entries(l.missions)) {
                    if (!o[planet]) {
                        o[planet] = [];
                    }
                    o[planet] = o[planet].concat(missions);
                }
            });
            return o;
        }
    }

    class PlanetMob {
        constructor (planet, mob) {
            Object.assign(this, mob);
            this.planet = planet;
            this.regions = mob.regions()[planet];
            this.missions = mob.missions()[planet];
            if (this.missions) {
                this.missions = this.missions.sort((a,b) => a.min_cl - b.min_cl);
                this.min_cl = Math.min(...this.missions.map(m => m.min_cl));
                this.max_cl = Math.max(...this.missions.map(m => m.max_cl));
                this.minReward = this.min_cl * missionRewardFactor;
                this.maxReward = this.max_cl * missionRewardFactor  + this.max_cl * missionRandomRewardFactor;
            }
            this.staticSpawns = mob.staticSpawns[planet];
        }

        missionNames () {
            return (this.missions || []).map(m => m.name + ' (' + m.min_cl + '-' + m.max_cl + ')');
        }
    }

    class Column {
        constructor (name, attribute, opts = {}) {
            this.name = name;
            this.attribute = attribute;
            this.sortable = true;
        }

        sort (dir) {
            return (a, b) => (a[this.attribute] - b[this.attribute]) * dir;
        }

        draw (cell, mob) {
            cell.appendChild(document.createTextNode(mob[this.attribute]));
        }
    }

    class NameColumn extends Column {
        constructor (name, attribute) {
            super(name, attribute);
            this.columnClasses = 'name-column';
        }

        sort (dir) {
            return (a, b) => {
                if (a.displayName.toUpperCase() > b.displayName.toUpperCase()) {
                    return dir;
                }
                if (a.displayName.toUpperCase() < b.displayName.toUpperCase()) {
                    return -dir;
                }
                return 0;
            };
        }

        draw (cell, mob) {
            mob.displayName = mob.name.replace(/^an? /, '').split(' ').map(s => capitalize(s)).join(' ');
            cell.classList.add('left');
            cell.appendChild(document.createTextNode(mob.displayName));
            if (mob.regions || mob.staticSpawns) {
                const spawns = document.createElement('span');
                spawns.classList.add('spawns', 'clickable');
                if (mob.staticSpawns) {
                    spawns.classList.add('static-spawns');
                }
                spawns.dataset.mob = mob.id;
                spawns.dataset.planet = mob.planet;
                spawns.appendChild(document.createTextNode('Map'));
                cell.appendChild(spawns);
            }
        }
    }

    class LevelColumn extends Column {
        sort (dir) {
            return (a, b) => ((a.min_cl || a.level) - (b.min_cl || b.level)) * dir;
        }

        draw (cell, mob) {
            if (mob.min_cl) {
                cell.appendChild(document.createTextNode('' + mob.min_cl + '-' + mob.max_cl));
                cell.title = 'Reward: ' + mob.minReward + '-' + mob.maxReward +
                    ' (IJM: ' + Math.round(mob.minReward * ijmFactor) + '-' + Math.round(mob.maxReward * ijmFactor) + '):\n  ' +
                    mob.missionNames().join("\n  ");
                cell.classList.add('missions');
            } else {
                cell.classList.add('no-missions');
                cell.appendChild(document.createTextNode('' + mob.level));
            }
        }
    }

    class ResourceColumn extends Column {
        constructor (name, attribute) {
            super(name, attribute);
            this.columnClasses = 'resource-column';
        }

        sort (dir) {
            const typeVar = this.attribute + '_type';
            return (a, b) => {
                const aType = a[typeVar] || '0';
                const bType = b[typeVar] || '0';
                if (aType.toUpperCase() > bType.toUpperCase()) {
                    return dir;
                }
                if (aType.toUpperCase() < bType.toUpperCase()) {
                    return -dir;
                }
                return (a[this.attribute] - b[this.attribute]) * dir;
            };
        }

        draw (cell, mob) {
            cell.classList.add('creature-resource');
            const type = mob[this.attribute + '_type'];
            const qty = mob[this.attribute];
            if (type) {
                cell.classList.add(type);
                const name = type.split('_')[1];
                const qtyElement = document.createElement('div');
                qtyElement.className = 'yield';
                qtyElement.appendChild(document.createTextNode(qty));
                cell.appendChild(qtyElement);
                const typeElement = document.createElement('span');
                typeElement.className = 'type';
                typeElement.appendChild(document.createTextNode(capitalize(name)));
                const shortTypeElement = document.createElement('span');
                shortTypeElement.className = 'short-type';
                shortTypeElement.appendChild(document.createTextNode(capitalize(name).substr(0,3) + '.'));
                cell.appendChild(typeElement);
                cell.appendChild(shortTypeElement);
            }
        }
    }

    class InfoColumn extends Column {
        constructor (name, attributes) {
            super(name, attributes);
            this.sortable = false;
        }

        draw (cell, mob) {
            cell.classList.add('info');
            // AR
            if (mob.armor && mob.armor > 0) {
                const ar = document.createElement('span');
                ar.classList.add('tag', 'armor', 'armor-' + mob.armor);
                ar.appendChild(document.createTextNode('AR:' + mob.armor));
                cell.appendChild(ar);
            }
            mob.attacks.sort().forEach(attack => {
                if (!ignoredTags.some(t => t.test(attack))) {
                    const tag = document.createElement('span');
                    tag.classList.add('tag', attack.split(' ')[0]);
                    let tagText = attack.replace('creaturearea', 'AoE ');
                    tagText = tagText.replace('attack', '');
                    tagText = tagText.replace('mild', '');
                    tagText = tagText.replace('medium', '');
                    tagText = tagText.replace('strong', '');
                    tag.appendChild(document.createTextNode(tagText));
                    cell.appendChild(tag);
                }
            });
        }
    }

    class ResistColumn extends Column {
        draw (cell, mob) {
            const resist = mob[this.attribute];
            let text = resist;
            if (resist === 0) {
                cell.classList.add('no-resist');
            } else if (resist === -1) {
                text = 'Vul';
                cell.classList.add('vulnerable');
            }

            cell.appendChild(document.createTextNode(text));
        }
    }

    class NumberColumn extends Column {
        draw (cell, mob) {
            const num = mob[this.attribute];
            let text = num;
            if (num > 1000) {
                text = (num / 1000).toString().substr(0, 3);
                text = text.replace('.0', '');
                if (text[text.length - 1] === '.') // Strip trailing .
                    text = text.substring(0, text.length - 1);
                text += 'K';
                if (num > 50000) {
                    cell.classList.add('omg');
                } else if (num > 10000) {
                    cell.classList.add('gold');
                } else if (num > 5000) {
                    cell.classList.add('silver');
                } else {
                    cell.classList.add('bronze');
                }
            }

            cell.appendChild(document.createTextNode(text));
        }
    }

    const columns = [
        new NameColumn('Creature', 'name'),
        new LevelColumn('CL', 'level'),
        new ResourceColumn('Meat', 'meat'),
        new ResourceColumn('Hide', 'hide'),
        new ResourceColumn('Bone', 'bone'),
        new ResourceColumn('Milk', 'milk'),
        new InfoColumn('Info', 'info')
    ];
    resists.forEach(r => columns.push(new ResistColumn(capitalize(r.substr(0, 3)), r + '_resist')));
    columns.push(new NumberColumn('HAM', 'ham'));
    columns.push(new NumberColumn('XP', 'xp'));
    const enabledColumnDefaults = ['name', 'level', 'meat', 'hide', 'bone', 'milk', 'info', 'kinetic_resist', 'energy_resist', 'ham', 'xp'];

    function parseData() {
        // Link spawns to lairs
        for (const [sid, spawn] of Object.entries(data.spawns)) {
            Object.keys(spawn['lairs']).forEach((lid) => {
                const lair = data.lairs[lid];
                if (!lair.spawns) {
                    lair.spawns = [];
                }
                lair.spawns.push(spawn);
            })
        }

        // Link regions to spawns
        for (const [planet, regions] of Object.entries(data.regions)) {
            for (const [key, region] of Object.entries(regions)) {
                region.id = key;
                region.spawns.forEach((sid) => {
                    const spawn = data.spawns[sid];
                    if (!spawn.regions) {
                        spawn.regions = {};
                    }
                    if (!spawn.regions[planet]) {
                        spawn.regions[planet] = [];
                    }
                    spawn.regions[planet].push(region);
                });
            }
        }

        // Link missions to lairs
        for (const [planet, missions] of Object.entries(data.missions)) {
            for (const [key, mission] of Object.entries(missions)) {
                const lair = data.lairs[key];
                if (!lair.missions) {
                    lair.missions = {};
                }
                if (!lair.missions[planet]) {
                    lair.missions[planet] = [];
                }
                lair.missions[planet].push(mission);
            }
        }

        // Link lairs to mobs
        for (const [lid, lair] of Object.entries(data.lairs)) {
            if (!lair.missions) {
                lair.missions = {};
            }
            if (!lair.spawns) {
                lair.spawns = [];
            }
            Object.keys(lair['mobs']).forEach((mid) => {
                const mob = data.mobs[mid];
                if (mob) {
                    if (!mob.lairs) {
                        mob.lairs = [];
                    }
                    mob.lairs.push(lair);
                }
            })
        }

        // Link static spawns to mobs
        for (const [planet, spawns] of Object.entries(data.static_spawns)) {
            for (const [mid, locs] of Object.entries(spawns)) {
                const mob = data.mobs[mid];
                if (mob) {
                    if (!mob.staticSpawns) {
                        mob.staticSpawns = {};
                    }
                    mob.staticSpawns[planet] = locs;
                }
            }
        }

        for (const [key, mobData] of Object.entries(data.mobs)) {
            const mob = new Mob(mobData);
            const planets = [...Object.keys(mob.missions()),
                ...Object.keys(mob.regions()),
                ...Object.keys(mob.staticSpawns)];
            for (const planet of planets) {
                if (!planetData[planet]) {
                    planetData[planet] = {};
                }
                planetData[planet][key] = new PlanetMob(planet, mob);
            }
        }

        createCols();
        createRows();
        document.getElementById('mobs').style.visibility = '';
        redraw();
    }

    function createCols() {
        const thead = document.getElementById('mobs').getElementsByTagName('thead')[0];
        const row = thead.insertRow();
        columns.forEach(column => {
            const heading = document.createElement('th');
            if (column.columnClasses) {
                heading.className = column.columnClasses;
            }
            if (column.sortable) {
                heading.dataset.sort = column.attribute;
            }
            heading.dataset.column = column.attribute;
            heading.appendChild(document.createTextNode(column.name));
            row.appendChild(heading);
        });
    }

    function createRows() {
        const tbody = document.getElementById('mobs').getElementsByTagName('tbody')[0];
        for (const [planet, mobs] of Object.entries(planetData)) {
            for (const mob of Object.values(mobs)) {
                const row = tbody.insertRow();
                mob.row = row;
                columns.forEach(column => {
                    const cell = row.insertCell();
                    column.draw(cell, mob);
                    cell.dataset.column = column.attribute;
                });
            }
        }
    }

    function redraw() {
        const tbody = document.getElementById('mobs').getElementsByTagName('tbody')[0];
        tbody.querySelectorAll('tr.planet').forEach(row => row.remove());

        for (const [planet, planetMobs] of Object.entries(planetData)) {
            const mobs = Object.values(planetMobs);
            applySort(mobs);
            const filteredMobs = applyFilter(mobs, planet);
            if (filteredMobs.length && !document.getElementById('planet-filter').value) {
                drawPlanetRow(tbody, planet);
            }
            mobs.forEach(function (mob) {
                mob.row.remove();
            });
            filteredMobs.forEach(function (mob) {
                tbody.appendChild(mob.row);
            });
        }

        setColumnVisibility();
    }

    function applyFilter(mobs, planet) {
        const planetFilter = document.getElementById('planet-filter').value;
        const includeSpawns = document.getElementById('spawn-filter').checked;
        const includeNpcs = document.getElementById('npc-filter').checked;
        const textFilter = (document.getElementById('text-filter').value || '').trim().toLowerCase();
        const clearTextFilter = document.getElementById('clear-text-filter');
        if (textFilter.length) {
            clearTextFilter.style.display = 'inline';
        } else {
            clearTextFilter.style.display = 'none';
        }
        return mobs.filter(function (mob) {
            if (planetFilter && (planetFilter !== planet)) {
                return false;
            }
            if (!includeSpawns && !mob.min_cl) {
                return false;
            }
            if (!includeNpcs && !(mob.type === 'MOB_CARNIVORE' || mob.type === 'MOB_HERBIVORE')) {
                return false;
            }
            if (textFilter && !textFilterable.some(k => mob[k] && mob[k].toLowerCase().includes(textFilter))) {
                return false;
            }
            return true;
        });
    }

    function applySort(mobs) {
        const column = columns.find(c => c.attribute === sort);
        mobs.sort(column.sort(sortDir));
    }

    function drawPlanetRow(tbody, planet) {
        const planetRow = tbody.insertRow();
        planetRow.classList.add('planet', planet);
        const planetCell = planetRow.insertCell();
        planetCell.appendChild(document.createTextNode(capitalize(planet)));
        planetCell.colSpan = 420;
        return planetRow;
    }

    function drawMap(element) {
        openOverlay('map');
        const mob = planetData[element.dataset.planet][element.dataset.mob];
        const map = document.querySelector('#map .image');
        map.className = 'image map-' + element.dataset.planet;
        map.innerHTML = '';
        const svg = svgNode('svg', { viewBox: '0 0 16000 16000' });
        map.appendChild(svg);
        document.querySelector('#mob-name').innerText = `${mob.displayName} spawns (${capitalize(mob.planet)})`;
        if (mob.regions) {
            mob.regions.forEach(region => {
                if (region.id.includes('world_spawner')) {
                    const worldSpawn = document.createElement('div');
                    worldSpawn.classList.add('world-spawn');
                    worldSpawn.appendChild(document.createTextNode('(Can also spawn globally)'));
                    map.appendChild(worldSpawn);
                } else {
                    if (region.shape[0] === 'rectangle') {
                        const x1 = region.shape[1] + 8000;
                        const y1 = 8000 - region.shape[2];
                        const x2 = region.shape[3] + 8000;
                        const y2 = 8000 - region.shape[4];
                        const x = Math.min(x1, x2);
                        const y = Math.min(y1, y2);
                        const width = Math.max(x1, x2) - x;
                        const height = Math.max(y1, y2) - y;
                        svg.appendChild(svgNode('rect', { x: x, y: y, width: width, height: height, fill: '#ff000066' }));
                    } else if (region.shape[0] === 'circle') {
                        const x = region.shape[1] + 8000;
                        const y = 8000 - region.shape[2];
                        const r = region.shape[3];
                        svg.appendChild(svgNode('circle', { cx: x, cy: y, r: r, fill: '#ff000066' }));
                    }
                }
            });
        }

        const staticSpawnList = document.getElementById('static-spawns');
        if (mob.staticSpawns) {
            staticSpawnList.style.display = 'block';
            staticSpawnList.innerText = '';
            staticSpawnList.appendChild(document.createTextNode("# Static spawns:\n"));
            mob.staticSpawns.forEach(spawn => {
                const x = spawn[0] + 8000;
                const y = 8000 - spawn[1];
                const text = '/waypoint ' + spawn[0] + ' ' + spawn[1] + ' ' + mob.name;
                svg.appendChild(svgNode('circle', {
                    cx: x, cy: y, r: 100, fill: '#ffee00', stroke: '#000000', 'stroke-width': 20, title: text }));
                staticSpawnList.appendChild(document.createTextNode(text + "\n"));
            });
        } else {
            staticSpawnList.style.display = 'none';
        }

        (cities[element.dataset.planet] || []).forEach(city => {
            const x = city[1] + 8000;
            const y = 8000 - city[2];
            svg.appendChild(svgNode('circle', {
                cx: x, cy: y, r: 100, fill: '#77ffff99', 'stroke-width': 80 }));
            const txt = svgNode('text', { x: x, y: y - 250, 'text-anchor': 'middle', style: 'fill: #ffffff; font-size: 300px' });
            txt.appendChild(document.createTextNode(city[0]));
            svg.appendChild(txt);
        });
    }

    function capitalize(string) {
        if (!string) {
            return '';
        }
        return string[0].toUpperCase() + string.slice(1);
    }

    function svgNode(node, props) {
        const n = document.createElementNS("http://www.w3.org/2000/svg", node);
        if (props) {
            for (const [key, value] of Object.entries(props)) {
                n.setAttributeNS(null, key, value);
            }
        }
        return n;
    }

    function openOverlay(id) {
        const bg = document.getElementById('overlay');
        bg.classList.add('open');
        bg.querySelectorAll('[data-overlay]').forEach(el => {
            if (el.dataset.overlay === id) {
                el.style.display = '';
            } else {
                el.style.display = 'none';
            }
        });
    }

    document.getElementById('mobs').addEventListener('click', function (e) {
        if (e.target.dataset.sort) {
            document.querySelectorAll('.sort-desc').forEach(n => n.classList.remove('sort-desc'));
            document.querySelectorAll('.sort-asc').forEach(n => n.classList.remove('sort-asc'));
            if (sort === e.target.dataset.sort) {
                sortDir = sortDir * -1;
            } else {
                sortDir = 1;
                sort = e.target.dataset.sort;
            }
            e.target.classList.add(sortDir === 1 ? 'sort-asc' : 'sort-desc');
            redraw();
        } else if (e.target.dataset.mob) {
            drawMap(e.target);
        }
    });

    document.getElementById('overlay').addEventListener('click', function (e) {
        if (e.target === this) {
            this.classList.remove('open');
        }
    });

    document.getElementById('close-overlay').addEventListener('click', function (e) {
        document.getElementById('overlay').classList.remove('open');
    });

    document.getElementById('planet-filter').addEventListener('change', function (e) {
        setTimeout(redraw, 5);
    });

    document.getElementById('spawn-filter').addEventListener('change', function (e) {
        setTimeout(redraw, 5);
    });

    document.getElementById('npc-filter').addEventListener('change', function (e) {
        setTimeout(redraw, 5);
    });

    document.getElementById('open-controls').addEventListener('click', function (e) {
        document.getElementById('controls').classList.toggle('open');
    });

    document.getElementById('dark-mode').addEventListener('change', function (e) {
        const enabled = this.checked;
        document.documentElement.setAttribute('data-theme', enabled ? 'dark' : '');
        localStorage.setItem('dark-mode', enabled ? 'true' : 'false');
    });

    const darkMode = (localStorage.getItem('dark-mode') === 'true') || window.matchMedia("(prefers-color-scheme: dark)").matches;
    document.getElementById('dark-mode').checked = darkMode;
    if (darkMode) {
        document.documentElement.setAttribute('data-theme', 'dark');
    }

    const enabledColumns = JSON.parse(localStorage.getItem('enabled-columns') || JSON.stringify(enabledColumnDefaults));
    document.querySelectorAll('[data-toggle-column]').forEach(n => n.checked = false);
    enabledColumns.forEach(c => {
        const checkbox = document.querySelector('[data-toggle-column="' + c + '"]');
        if (checkbox) {
            checkbox.checked = true;
        }
    });
    document.querySelectorAll('[data-toggle-column]').forEach(n => {
        n.addEventListener('change', function (e) {
            const col = n.dataset.toggleColumn;
            if (this.checked) {
                enabledColumns.push(col);
            } else {
                const index = enabledColumns.indexOf(col);
                if (index > -1) {
                    enabledColumns.splice(index, 1);
                }
            }
            localStorage.setItem('enabled-columns', JSON.stringify(enabledColumns));
            setColumnVisibility();
        });
    });
    function setColumnVisibility() {
        columns.forEach(c => {
            const display = (enabledColumns.indexOf(c.attribute) === -1) ? 'none' : '';
            document.querySelectorAll('[data-column="' + c.attribute + '"]').forEach(cell => cell.style.display = display);
        });
    }

    let filterDebounce;
    document.getElementById('text-filter').addEventListener('keyup', function (e) {
        if (filterDebounce)
            clearTimeout(filterDebounce);
        filterDebounce = setTimeout(redraw, 100);
    });

    document.getElementById('clear-text-filter').addEventListener('click', function (e) {
        document.getElementById('text-filter').value = '';
        redraw();
    });

    document.getElementById('overlay').addEventListener('mousemove', function (e) {
        const svg = this.querySelector('svg');
        if (svg) {
            const domPoint = new DOMPointReadOnly(e.clientX, e.clientY);
            const pt = domPoint.matrixTransform(svg.getScreenCTM().inverse());
            const coords = document.getElementById('coords');
            if (pt.x < 0 || pt.y < 0 || pt.x > 16000 || pt.y > 16000) {
                coords.innerText = '';
            } else {
                coords.innerText = '' + Math.round(pt.x - 8000) + ' ' + Math.round(8000 - pt.y);
                // coords.style.left = e.clientX + 'px';
                // coords.style.top = e.clientY + 20 + 'px';
            }
        }
    });
</script>
</body>
</html>
